{
  "comments": [
    {
      "key": {
        "uuid": "9a561d44_8c82d3fe",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 5278
      },
      "writtenOn": "2016-06-28T08:56:25Z",
      "side": 1,
      "message": "I see etree is augmented into elan. It should be other way around. For me, elan is special case of etree (i.e. etree is created with only root interfaces).",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a561d44_80aa97d2",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 5703
      },
      "writtenOn": "2016-06-28T09:55:44Z",
      "side": 1,
      "message": "I agree this could have gone both ways, but I don\u0027t see a great advantage in doing that. On the contrary, making elan augment etree would have caused a massive code change for the current code base of elan, and we tried to minimize code effects.",
      "parentUuid": "9a561d44_8c82d3fe",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a561d44_60882323",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 2,
      "author": {
        "id": 5278
      },
      "writtenOn": "2016-06-28T10:27:04Z",
      "side": 1,
      "message": "Yes, I agree that it will blow up the code. But in the longer run, elan/etree/eline etc. should get augmented under l2service, so that there will be clearer separation between each services.",
      "parentUuid": "9a561d44_80aa97d2",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a561d44_4cb6fbdd",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 37,
      "author": {
        "id": 5278
      },
      "writtenOn": "2016-06-28T08:56:25Z",
      "side": 1,
      "message": "I don\u0027t think it is necessary to define etree-leaf-tag and get it stored in MD-SAL datastore. The etree-root-tag and etree-leaf-tag can be calculated in the run time using a formula on etree-id like we do it for deriving ELAN Local/Remote BC group id\u0027s.",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a561d44_40eebf23",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 37,
      "author": {
        "id": 5703
      },
      "writtenOn": "2016-06-28T09:55:44Z",
      "side": 1,
      "message": "ETreeRootsTag \u003d\u003d ElanTag\nEtreeLeavesTag \u003d\u003d a new elan TAG we allocated especially for leaves interfaces.\nBecause it is allocated by the IdManager which guarantee uniqueness, we used it to allocate the Leaves Tag as well. What manipulation do you suggest that would have given us a unique id which can\u0027t conflict with a future IdManager tags?\nBTW, the ID we pass to the IdManager to get the leaves tag is: ElanName + Postfix. The postfix is \"_leaves\".",
      "parentUuid": "9a561d44_4cb6fbdd",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a561d44_809e1755",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 37,
      "author": {
        "id": 5278
      },
      "writtenOn": "2016-06-28T10:27:04Z",
      "side": 1,
      "message": "IdManager involves id pool locking and some data store writes. So it has performance impact in highly scaled deployment. \n\nPlease use the following manipulation:\n\nETreeRootsTag \u003d ElanConstants.ETREE_LABEL_MIN + (((elanTag % ElanConstants.ETREE_LABEL_MIN) *2) - 1); \n\nEtreeLeavesTag \u003d ElanConstants.ETREE_LABEL_MIN + (((elanTag % ElanConstants.ETREE_LABEL_MIN) *2));",
      "parentUuid": "9a561d44_40eebf23",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9a561d44_1796b594",
        "filename": "vpnservice/elanmanager/elanmanager-api/src/main/yang/etree.yang",
        "patchSetId": 8
      },
      "lineNbr": 37,
      "author": {
        "id": 5703
      },
      "writtenOn": "2016-07-01T06:32:40Z",
      "side": 1,
      "message": "EtreeRootsTag \u003d\u003d elanTag. It is not a different entity in our solution. This is what I\u0027m matching on in table 0. Separating it to another value will add complication to the code. Because Elan is like Etree with all roots, the root interfaces behave exactly the same like Elan. They can communicate will all other interfaces, and all other interfaces can communicate with them. This is why it is the same entity as elan tag.\nThe only performance impact here is another lock for the data stores (2 locks instead of the original 1), and it\u0027s per network not per interface. So we are not talking on a high-frequency event.",
      "parentUuid": "9a561d44_809e1755",
      "revId": "a3c302f97108d3ff13de770869f480a7e0df2b28",
      "serverId": "7fc14799-209e-464c-9743-7a06c2c21a81",
      "unresolved": false
    }
  ]
}